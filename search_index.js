var documenterSearchIndex = {"docs":
[{"location":"theory/","page":"Theory","title":"Theory","text":"It can be useful to create a mathematical model for Eternity II puzzles, in order to compare the efficiencies of different solving strategies without the need to gather empirical results, to find an estimation for the number of solutions, and to derive a measure for the difficulty of a given puzzle. The following section first describes some of the terms that are used in this documentation and also in the source code.","category":"page"},{"location":"theory/#Terminology","page":"Theory","title":"Terminology","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"An Eternity II puzzle is a special kind of edge-matching puzzle on a rectangular grid – the board – with a given number of rows and columns. The rows and columns divide the board into a set of squares, with each square being identified by a combination of a letter for the row (from top to bottom) and a number for the column (from left to right); for example A1 for the top-left corner square.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The puzzle pieces (or tiles) have one of various colored patterns on each of their four sides. For simplicitly these different edge types are just called the colors. One of the edge types that occurs on some of the pieces doesn't have an actual pattern; this is the grey border color and edges of that type are the border edges. Border edges must only be placed towards the outside border of the board. We can distinguish between corner pieces (pieces with two border edges), edge pieces (pieces with one border edge) and inner pieces (pieces without border edges), while the set of frame pieces consists of the corner pieces and the edge pieces. The corner squares, edge squares, inner squares and frame squares are the corresponding positions on the board. A fixed piece (or pre-placed piece) is a piece that must be placed with a given rotation on a given square of the board - the original Eternity II puzzle has a single fixed piece on square I8.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"An important property of the Eternity II puzzle is that the set of colors which occur on the edges between two frame pieces, and the set of colors which occur on the edges between two inner pieces and between one inner piece and one frame piece, are disjunct. This separates the colors into frame colors, which only occur on frame pieces, and inner colors, which occur on the inner pieces and on the inside edges of the edge pieces.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A join describes a pair of edges between two adjacent pieces, and similarly to the frame and inner colors we can further distinguish between frame joins and inner joins. The joins can either be valid joins if both of the edge colors match, or invalid joins if they don't match. Since there is only a single valid rotation for the pieces on the frame squares (determined by the orientation of the border edge), frame joins are always made from two edges with frame colors and inner joins are always made from two edges with inner colors, regardless whether these joins are valid or invalid.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The score of an arrangement of pieces on the board is defined as the total number of valid joins. At the time of writing, the highest known score for the original Eternity II puzzle are 470 valid joins out of the maximum 480.","category":"page"},{"location":"theory/#Symmetries","page":"Theory","title":"Symmetries","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"A puzzle can have three possible types of symmetries, which act as multiplicative factors for the total number of solutions. The symmetries can also be utilized to reduce the number of nodes in the search tree that a backtracking algorithm has to visit in order to find all possible solutions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Symmetries due to the board:  For a square board without fixed pieces, any solution rotated by 90°, 180° or 270° is also a solution.  For a rectangular board with different numbers of rows and columns, any solution rotated by 180° gives another solution.  On a square board, fixing one of the four corner pieces reduces the number of nodes for an exhaustive search by an average factor of 4 (the precise number of nodes depends on which particular corner piece was used, because the colors of its edges affect the number of possible candidates for the neighboring pieces and so on).  Similarly, for a rectangular but not square board, fixing one of the corner pieces on one of the corner squares first and then on another corner square that is not directly opposite to the first one, reduces the number of nodes for an exhaustive search by an average factor of 2.\nSymmetries due to rotationally symmetric individual pieces:  If a piece has the same edge colors on opposite sides both in vertical and horizontal direction, the piece can be rotated by 180° without affecting the global edge color arrangement on the board.  If all four of its edges have the same color, the piece can be rotated by 90°, 180° or 270°.\nSymmetries due to rotationally identical pieces:  If two or more pieces have exactly the same edge colors under some rotation, their positions on the board can be swapped without affecting the global edge color arrangement.  In general, for each set of n duplicate pieces there are n permutations for the positions of these pieces with identical edge color arrangement.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The original Eternity II puzzle has neither symmetrical individual nor rotationally identical pieces, and for a valid solution the symmetries due to the board are eliminated by fixing piece 139 on the square I8.","category":"page"},{"location":"theory/#Solution-estimates","page":"Theory","title":"Solution estimates","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"To get an estimate for the number of valid solutions, we can count the total number of possible piece configurations on the board, and multiply that number with the probability that all joins between adjacent edges have matching colors.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The number of piece configurations – ignoring whether or not adjacent edges match – can be calculated exactly. For the original Eternity II puzzle with 16 rows and 16 columns there are 4 corner pieces, 56 edge pieces and 196 inner pieces, with one of the inner pieces already being fixed with a given rotation on square I8. Under the restriction that the frame pieces must be placed with all their border edges around the outside of the board, we have 4 = 24 different permutations for the arrangement of the corner pieces, 56 possible configurations of the edge pieces, and 195cdot 4^195 possible configurations for the inner pieces, including the four rotations for each piece. In total this yields 4cdot 56cdot 195cdot 4^195approx 112cdot 10^557 possible configurations for all the pieces.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The board of the Eternity II puzzle has 60 frame joins and 420 inner joins, and there are 5 different frame colors and 17 different inner colors with flat distributions over the number of edges. A very simple approach is to use the value 15 as an approximation for the probability of a valid frame join, and 117 for the probability of a valid inner join. If the probabilities of valid joins are assumed to be independent over the entire board, one could simply multiply these values and get the total probability (15)^60cdot (117)^420approx 188cdot 10^-559 that all of the joins are valid. Then the expected number of solutions is the product from the number of all possible configurations and the probability that all joins for a particular configuration are valid. With the values from above we expect 002 solutions, which suggests that the puzzle has only a single solution – the one that was used to generate the puzzle pieces. However, when comparing this method with empirical results from puzzles with fewer pieces, which can be searched exhaustively with a backtracking algorithm, it becomes apparent that this approximation is not very accurate. In fact, it is clear that in practice the probabilities of valid joins are not independent and constant over the whole board; after more and more pieces are correctly placed onto the board, the color distribution over the remaining edges changes and the probability to create valid joins increases as some of the colors get used up.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A more sophisticated probability model was developed by Brendan Owen [1, 2], which takes into account that the numbers of edges of each color are finite. This model is generalized for any number of fixed pieces on the board, and for any configuration of squares on a partially filled board, which will be useful to estimate the total number of nodes in a search tree that a backtracking algorithm has to visit for an exhaustive search.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the following, we use the notation P(n k) = n(n-k) for the number of k-permutations of n, and C(n k) = n(k(n-k)) for the number of k-combinations of n (binomial coefficient).","category":"page"},{"location":"theory/#Number-of-piece-configurations","page":"Theory","title":"Number of piece configurations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let a_textc be the number of available corner pieces, a_texte be the number of available edge pieces, and a_texti be the number of available inner pieces. Each of these numbers are counted without the fixed pieces on the board. Note that these numbers are allowed to be larger than the corresponding numbers of board squares of each type; this makes it possible to, for example, calculate estimations about filling a smaller board with a subset of pieces made from any of the 256 Eternity II pieces.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Further, for any partially or completed piece configuration on the board, let p_textc be the number of placed corner pieces, p_texte be the number of placed edge pieces, and p_texti be the number of placed inner pieces, but again, counted without any fixed pieces.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, for a specific selection of squares on the board, the number of possible piece configurations that fill these squares, and ignoring whether joins between adjacent pieces match or not, is given by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(p_textc p_texte p_texti) = P(a_textc p_textc) P(a_texte p_texte) P(a_texti p_texti) 4^p_texti = fraca_textc(a_textc - p_textc)cdotfraca_texte(a_texte - p_texte)cdotfraca_texti(a_texti - p_texti) 4^p_texti","category":"page"},{"location":"theory/#Matching-probabilities","page":"Theory","title":"Matching probabilities","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next part is to determine the probability that all the edges are matching. The probability for a particular state of a partially filled board is taken as the ratio between the number of valid combinations for a given number of joins (corresponding to the particular state of the board) and the total number of combinations how that many joins can be made from either matching or non-matching edges with arbitrary colors. This model assumes that the edges can be moved independently from each other, which is not strictly true as groups of four edges are attached to a piece.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The basic idea of the following method involves to calculate the number of valid combinations by just using a subset of the colors, and then incrementally adding new colors with the help of that result as a building block in the calculation. This process is repeated until all edge types have been taken into account. The concept leads to recursive formulas for the numbers of valid combinations, which can be implemented very efficiently.","category":"page"},{"location":"theory/#Probabilities-of-valid-frame-joins","page":"Theory","title":"Probabilities of valid frame joins","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"It was already mentioned before, that the orientations of the frame pieces are constrained by their border edges. This means that a join between two frame pieces is always made from one \"left\" edge and one \"right\" edge.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let B be the number of different frame colors and assign consecutive numbers from 1 to B to those colors. Let 2n_i be the number of edges of color i and 2T_textb = 2sum_i=1^B n_i be the total number of frame edges over all pieces. Define V_textb(i b) to be the number of valid configurations of how b frame joins can be made using 2b edges of colors 1 to i. It is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nV_textb(0 0) = 1 \nV_textb(0 b) = 0 quad textfor quad b  0\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and one can derive the recursive formula","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"V_textb(i b) = sum_j=0^n_i V_textb(i-1 b-j)cdot P(n_i j)^2cdot C(b j)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"by adding up the ways 0 to n_i extra joins can be made when adding the color i. Hereby are V_textb(i-1 b-j) the number of valid configurations using just the previous colors with b-j joins, P(n_i j)^2 the ways of making j joins using j edges from a set of n_i left edges and j edges from a set of n_i right edges, and C(b j) are the ways of merging b-j joins with the j new joins to make b joins.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the total number of ways to make b joins using 2b edges, regardless whether they are valid or invalid, we just pick b left edges from the total set of T_textb left edges and b right edges from the total set of T_textb right edges. This results in a number of P(T_textb b)^2 permutations, and a corresponding probability","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textb(b) = fracV_textb(B b)P(T_textb b)^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"that all b frame joins are valid, using 2b frame edges.","category":"page"},{"location":"theory/#Probabilities-of-valid-inner-joins","page":"Theory","title":"Probabilities of valid inner joins","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The approach for the inner joins works similar to that one for the frame joins. The difference in this case is that there is no such notion of left or right edges for the inner joins, and thus instead of P(n_i j)^2 ways to make j joins from the n_i left and n_i right edges of color i we now have P(2n_i 2j) ways to pick any 2j edges from the total of 2n_i edges with that color.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let M be the number of different inner colors, with color numbers assigned from 1 to M. Again, let 2n_i be the number of edges of color i and 2T_textm = 2sum_i=1^M n_i the total number of inner edges over all pieces. Define V_textm(i m) to be the number of valid configurations of how m inner joins can be made using 2m edges of colors 1 to i. Then we have again","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nV_textm(0 0) = 1 \nV_textm(0 m) = 0 quad textfor quad m  0\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the recursive formula","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"V_textm(i m) = sum_j=0^n_i V_textm(i-1 m-j)cdot P(2n_i 2j)cdot C(m j)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"from which follows the probability","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textm(m) = fracV_textm(M m)P(2T_textm 2m)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"that all m inner joins are valid, using 2m inner edges.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figures 1 and 2 show the probabilities of a particular join to be valid, plotted over the cumulative number of joins for the Eternity II puzzle with 256 pieces, 60 total frame joins and 420 total inner joins.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure>\n  <picture style=\"width: 100%\">\n    <source srcset=\"../assets/frame_probabilities_dark.svg\" media=\"(prefers-color-scheme: dark)\">\n    <img src=\"../assets/frame_probabilities.svg\">\n  </picture>\n  <figcaption><b>Figure 1</b>: Probabilities of valid frame joins for the Eternity II puzzle with 256 pieces</figcaption>\n</figure>\n\n<figure>\n  <picture style=\"width: 100%\">\n    <source srcset=\"../assets/inner_probabilities_dark.svg\" media=\"(prefers-color-scheme: dark)\">\n    <img src=\"../assets/inner_probabilities.svg\">\n  </picture>\n  <figcaption><b>Figure 2</b>: Probabilities of valid inner joins for the Eternity II puzzle with 256 pieces</figcaption>\n</figure>","category":"page"},{"location":"theory/#Solutions-and-search-tree-estimates","page":"Theory","title":"Solutions and search tree estimates","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The product of the probabilities for b valid frame joins made from 2b frame edges and m valid inner joins  made from 2m inner edges and the total number of piece configurations with p_textc placed corner pieces, p_texte placed edge pieces and p_texti placed inner pieces gives an estimation for the number of partial solutions of a partially filled board:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"S(p_textc p_texte p_texti b m) = P(p_textc p_texte p_texti)cdot p_textb(b)cdot p_textm(m)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a board with r rows and c columns, that has","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\ns_textc = 4 \ns_texte = 2(r-2) + 2(c-2) = 2r + 2c - 8 \ns_texti = (r-2)(c-2)\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"corner squares, edge squares and inner squares, and using","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nb = 2(r-1) + 2(c-1) \nm = (r-1)(c-2) + (r-2)(c-1)\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"as the total numbers of frame joins and inner joins on the board, we finally have the estimation for the number of puzzle solutions of the entirely filled board.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Table 1 compares the predicted numbers of solutions with empirical results for the two smaller puzzles with 36 pieces that are shown in figure 3.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure style=\"display: flex; justify-content: space-around; flex-wrap: wrap\">\n  <span></span>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/pieces_06x06.png\">\n    <figcaption>Puzzle A: 3 frame colors, 5 inner colors,<br>160 solutions</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/clue1.png\">\n    <figcaption>Puzzle B: 4 frame colors, 3 inner colors, 115071633408 solutions</figcaption>\n  </figure>\n  <figcaption><b>Figure 3</b>: 6x6 puzzles with different characteristics</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":" Puzzle A Puzzle B Eternity II\nestimated solutions 146 262881014825 14702\nactual solutions 160 115071633408 \nsymmetries due to the board 4 4 1\nsymmetries due to symmetric pieces 1 4 1\nsymmetries due to identical pieces 1 384 1\ntotal symmetries 4 6144 1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure>\n  <figcaption><b>Table 1</b>: Estimated and empirical numbers of solutions for different puzzles</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A backtracking search algorithm gradually fills the board with pieces one after another, and following a given search order, which maps each search depth to a particular square on the board. After each placed piece for that search order we can count the total numbers of the already placed corner, edge and inner pieces, as well as the numbers of frame joins and inner joins between neighboring pieces, and then estimate the number of partial solutions for that particular, partially filled board. The cumulative sum of these partial solutions, from placing the first until the last piece, represents an estimation for the total numbers of nodes in the search tree.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It has been observed that the predicted numbers from the theoretical model matches empirical results gathered by exhaustive searches very well, and the relative error becomes smaller with bigger puzzle sizes. Figure 4 shows two different puzzles with 64 pieces, but with the same characteristics (3 frame colors, 8 inner colors, no symmetric or identical pieces), and figure 5 visualizes the estimated and empirical numbers of nodes for each depth in the search tree, using a simple rowscan search order starting from the bottom-left corner.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure style=\"display: flex; justify-content: space-around; flex-wrap: wrap\">\n  <span></span>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/pieces_08x08_set_1.png\">\n    <figcaption>Puzzle C: 52 solutions</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/pieces_08x08_set_2.png\">\n    <figcaption>Puzzle D: 96 solutions</figcaption>\n  </figure>\n  <figcaption><b>Figure 4</b>: 8x8 puzzles with 3 frame colors and 8 inner colors</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure>\n  <picture style=\"width: 100%\">\n    <source srcset=\"../assets/search_tree_8x8_dark.svg\" media=\"(prefers-color-scheme: dark)\">\n    <img src=\"../assets/search_tree_8x8.svg\">\n  </picture>\n  <figcaption><b>Figure 5</b>: Estimated and empirical numbers of nodes in the search tree</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 6 visualizes different search orders for the original Eternity II puzzle with a single fixed piece on square I8, and shows the total number of nodes in the corresponding search trees. It is worth to mention that the optimal optimal search order depends on the specific properties of the puzzle, i.e. the board size, the number of frame and inner colors, the distribution of colors, and the number of symmetries in the pieces.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure style=\"display: flex; justify-content: space-around; flex-wrap: wrap\">\n  <span></span>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_rowscan.svg\">\n    <figcaption>Horizontal rowscan - 1.365e+47 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_best.svg\">\n    <figcaption>Best known search order - 1.364e+47 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_frame_rowscan.svg\">\n    <figcaption>Frame first, then horizontal rowscan - 1.110e+57 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_zig_zag.svg\">\n    <figcaption>Diagonal zig-zag path - 4.176e+53 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_spiral_in.svg\">\n    <figcaption>Spiral-in path - 3.979e+57 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_spiral_out.svg\">\n    <figcaption>Spiral-out path - 1.556e+57 nodes</figcaption>\n  </figure>\n  <figcaption><b>Figure 6</b>: Different search orders and the total number of nodes in the corresponding search trees</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure>\n  <picture style=\"width: 100%\">\n    <source srcset=\"../assets/search_tree_dark.svg\" media=\"(prefers-color-scheme: dark)\">\n    <img src=\"../assets/search_tree.svg\">\n  </picture>\n  <figcaption><b>Figure 7</b>: Search tree estimates for selected search orders</figcaption>\n</figure>","category":"page"},{"location":"theory/#Estimates-with-invalid-joins","page":"Theory","title":"Estimates with invalid joins","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a simple backtracking approach, the search space of the Eternity II puzzle with 256 pieces is too large for a realistic chance of finding one of the solutions. A different objective can be to optimize for the best score, i.e. the highest number of valid joins on the board. This involves to allow a certain amount of mismatched edges while placing new pieces onto the board. Since the probability of valid joins between two random frame pieces of the Eternity II puzzle is higher than the probability of valid inner joins, the following model only considers the invalid joins between two inner edges and assumes that all edges between the frame pieces must still match.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let p_textm(m v) be the probability that the first v inner joins are valid and the rest are not, using 2m inner edges. This probability can be calculated using the recursive relation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textm(m v) = p_textm(m-1 v) - p_textm(m v+1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the special case of all m inner joins to be valid was already considered above, therefore","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textm(m m) = p_textm(m)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we want to allow the v valid inner joins to be anywhere on the board, we still have to multiply p_textm(m v) with the number of ways to arrange v valid joins over m positions, i.e. with a factor C(m v) = C(m m-v).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"More convenient for practical calculations is the probability of at most N = m - v invalid inner joins, using 2m edges. In this case we have to sum up the probabilities p_textm(m m-0) for no invalid joins, p_textm(m m-1) for 1 invalid join, up to p_textm(m m-N) for N invalid joins, with each of these probabilities multiplied the number of ways of arranging the corresponding number of invalid joins over all of the m inner joins:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textm = sum_i=0^N p_textm(m m-i)cdot C(m i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here, for simplicity the notation p_textm on the left side of the equation represents the overall probability regarding the inner joins, and its exact meaning should be clear from context, i.e. in this case it is the probability for up to N invalid joins anywhere on the board.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since allowing invalid joins increases the numbers of possible piece candidates for each square in a backtracking algorithm, an efficient implementation would likely restrict where exactly on the board these invalid joins are allowed. For example, instead of right from the beginning and over the entire board, the invalid joins might only be gradually allowed towards the end of the search, after some specified numbers of placed pieces (\"slip array\"). In this case we have to replace the factor C(m i) in the equation by the number of ways to arrange i invalid joins over a total of m joins, while satisfying the restictions from the given slip array.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let d=d_1 d_2 ldots d_N with d_1le d_2leldotsle d_N be an ordered slip array with N entries, that specifies the search depths (i.e. the number of placed pieces) at which another invalid join is allowed. For example, d=220 230 240 means that the first 219 pieces must be placed without any invalid joins, from piece 220 to 229 at most one invalid join is allowed, from piece 230 to 239 at most two (cumulative) invalid joins, and a third invalid join is allowed when at least 240 pieces are placed. It is not strictly necessary that the first invalid join occurs somewhere between piece 220 to 229; instead, all of the three allowed invalid joins might be between the last few placed pieces, or there can also be fewer than three invalid joins in total. Note that multiple consecutive numbers with the same value in d are allowed, in which case the corresponding number of new invalid joins are allowed from that particular search depth. For example, to allow up to four invalid inner joins anywhere on the board, you could simply set d=1 1 1 1 (in practice it doesn't really make sense to have more than two consecutive numbers with the same value, because new pieces are usually only placed with exactly two of their edges adjacent to other pieces on the board). Also note that by defining the allowed invalid joins in form of the slip array, their allowed positions on the board are dependent on the search order.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let j(p) be the number of completed (either valid or invalid) inner joins after p placed pieces, with 1le ple p_textmax and p_textmax being the total number of squares on the board. The values j(p) depend on the exact placement order of the pieces, but they can easily be precomputed and stored in an array.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let W(p i) be the number of ways to arrange exactly i invalid inner joins after p placed pieces on the board, that satisfy the constraints from the given slip array d.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Obviously W(p i) = 0 if p  d_i, because i invalid joins are not permitted when fewer than d_i pieces are placed on the board.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a single invalid join any of the last j(p) - j(d_1-1) positions is allowed, and therefore","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"W(p 1) = C(j(p) - j(d_1-1) 1) = j(p) - j(d_1-1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For exactly i=2 invalid joins, either both of them can be between d_2 and p placed pieces (here \"between\" means the bounds d_2 and p are inclusive), or one of them can be between d_1 and d_2 - 1 placed pieces and the other one between d_2 and p placed pieces. For the first case we have C(j(p) - j(d_2-1) 2) combinations to arrange the two invalid joins, and for the second case we have C(j(d_2-1) - j(d_1-1) 1)cdot C(j(p) - j(d_2-1) 1) combinations to arrange them. In total this gives","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"W(p 2) = C(j(p) - j(d_2-1) 2) + underbraceC(j(d_2-1) - j(d_1-1) 1)_W(d_2-1 1)cdot C(j(p) - j(d_2-1) 1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"possible configurations for exactly 2 invalid joins.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now consider an arbitrary number of exactly i invalid joins after p placed pieces. We can list the different cases:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"All i invalid joins occur between d_i and p placed pieces. This gives C(j(p) - j(d_i-1) i) possible configurations.\nThere is exactly 1 invalid join between d_1 and d_i - 1 placed pieces and the other i-1 invalid joins occur between d_i and p placed pieces. This gives C(j(d_i-1) - j(d_1-1) 1)cdot C(j(p) - j(d_i-1) i-1) possible configurations. Notice that the first term in that product is equal to W(d_i - 1 1).\nThere are exactly 2 invalid joins between d_1 and d_i - 1 placed pieces and the other i-2 invalid joins occur between d_i and p placed pieces. We have already calculated the number of possible configurations for the first 2 invalid joins in the previous paragraph if we again set p = d_i - 1. This gives W(d_i - 1 2)cdot C(j(p) - j(d_i-1) i-2) possible configurations.\nThere are exactly k invalid joins between d_1 and d_i - 1 placed pieces and the other i-k invalid joins occur between d_i and p placed pieces. This gives W(d_i - 1 k)cdot C(j(p) - j(d_i-1) i-k) possible configurations.\nThere are exactly i-1 invalid joins between d_1 and d_i - 1 placed pieces and the last invalid join occurs between d_i and p placed pieces. This gives W(d_i - 1 i - 1)cdot C(j(p) - j(d_i-1) 1) possible configurations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The total number of possible configurations for i invalid joins is the sum of all of these cases, which can be written in a recursive way","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nW(p i) = begincases sumlimits_k=0^i-1 W(d_i - 1 k)cdot C(j(p) - j(d_i-1) i-k)  textif  pge d_i  0  textif  p  d_i endcases \nW(p 0) = 1\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Using this expression, we can now calculate the probability for the inner joins with up to N invalid joins after p placed pieces, that satisfy the restrictions from the given slip array, as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"p_textm = sum_i=0^N p_textm(m m-i)cdot W(p i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that if invalid joins are allowed only for the inner edges, the optimal search order is usually different from the best search order if no invalid joins were allowed. The reason for that is because allowing mismatching inner edges significantly increases the number of possible piece candidates for the inner board squares. Therefore a search order which prioritizes the frame squares during the later phase of the search when invalid joins are allowed is more efficient than a search order which for example leaves the entire top row of the board until the very end. Figures 8 and 9 show the total number of nodes in the search tree for two different search orders, assuming that up to 10 invalid inner joins (target score 470) within the four topmost rows of the Eternity II board are allowed, which corresponds to the slip array","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"192 192 192 192 192 192 192 192 192 192","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and an estimated number of 1481cdot 10^25 piece configurations that satisfy these constraints. Here the search order on the right, which only fills the first 12 rows horizontally and then the last 4 rows vertically, is over 80% more efficient than a full horizontal rowscan over the entire board.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure style=\"display: flex; justify-content: space-around; flex-wrap: wrap\">\n  <span></span>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_rowscan.svg\">\n    <figcaption>Horizontal rowscan - 3.715e+58 nodes</figcaption>\n  </figure>\n  <figure style=\"width: 40%\">\n    <img src=\"../assets/path_rowscan2.svg\">\n    <figcaption>Horizontal rowscan with the last 4 rows filled vertically - 7.000e+57 nodes</figcaption>\n  </figure>\n  <figcaption><b>Figure 8</b>: Two search orders for the Eternity II puzzle with up to 10 invalid joins allowed</figcaption>\n</figure>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<figure>\n  <picture style=\"width: 100%\">\n    <source srcset=\"../assets/search_tree_470_dark.svg\" media=\"(prefers-color-scheme: dark)\">\n    <img src=\"../assets/search_tree_470.svg\">\n  </picture>\n  <figcaption><b>Figure 9</b>: Search tree estimates with up to 10 invalid joins allowed</figcaption>\n</figure>","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"B. Owen. Complex theory, https://groups.io/g/eternity2/message/5209 (2008).\n\n\n\nB. Owen. Complex theory with edge slip, https://groups.io/g/eternity2/message/6408 (2009).\n\n\n\n","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This page explains the different strategies for solving Eternity II puzzles, which are implemented in this package.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"warning: Under construction\nThis page is not fully written yet and most of the content is just an early draft version.","category":"page"},{"location":"solvers/#Backtracking-search","page":"Solvers","title":"Backtracking search","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"A common approach for solving edge-matching puzzles like the Eternity II puzzle is a backtracking search. Hereby the pieces are placed one after another onto the board, and as soon as no more piece can be placed, the last one is removed and another piece is tried instead. An efficient implementation precomputes a lookup table with all possible piece candidates that fit for each combination of two edge colors, which during the search are the constraints from the edges of the neighboring pieces. Such a lookup table contains all pieces pre-rotated in four different orientations.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The backtracking algorithm corresponds to exploring a search tree, where each node of the tree represents a piece that is placed during the search. The depth of this search tree is defined by the total number of squares on the board (which is 256 for the original 16x16 Eternity II puzzle - or 255 if the starter-piece is considered as pre-placed on square I8), and the width for each level depends on a branching factor defined by the number of possible piece candidates for a particular board square. For example, if the backtracking algorithm starts at the corner square A1, there are 4 possible corner pieces to choose from. In the next step one of the 56 edge pieces should be placed on the next square A2 adjacent to this corner, but there is only a subset of these edge pieces which satisfy the constraint of matching edge colors with the already placed corner piece. In particular, for the original Eternity II pieces and depending on which of the corner pieces was placed, there are between 10 and 12 matching edge pieces for the square A2. This yields a total of 45 different combinations of corner and adjacent edge piece, or 4 + 45 = 49 cumulative nodes for the first two levels of the search tree. As the search proceeds and more pieces are placed onto the board, the branching factor becomes smaller because there are fewer remaining pieces to choose from.","category":"page"},{"location":"solvers/#Search-order","page":"Solvers","title":"Search order","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"As already discussed on the previous page, the order in which pieces are placed onto the board has a significant influence on the width of the search tree and therefore on the efficiency of the search algorithm. For the Eternity II puzzle, it is best to start at the bottom-left corner, which is the closest corner to the fixed starter-piece on square I8. To keep the implementation simple and efficient, we only consider search orders in which each newly placed piece has always two adjacent edges from other, already placed pieces on the bottom and on the left side. Then the orientation to the neighboring pieces doesn't need to be considered when looking up the edge constraint in the piece candidates table. The optimal search order depends on the allowed number of invalid joins and where exactly on the board they are allowed. The current implementation uses the search order shown in figure 1.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"<figure>\n  <img src=\"../assets/path_e2.svg\">\n  <figcaption><b>Figure 1</b>: Search order for the Eternity II puzzle</figcaption>\n</figure>","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"note: A note about dynamic search orders\nInstead of using a predetermined search order, it might seem like a good idea to compare the numbers of piece candidates for different squares after every placed piece, and then choose the next square to be the one with the fewest possible candidates. However, aside from making the implementation more difficult, such a dynamic search order is actually significantly less efficient than a good, fixed search order. The reason for that is because choosing the next square by using a greedy strategy minimizes the branching factor of the search tree early on, but it generates partially filled board configurations which leave less optimal choices later during the search. So it is better to have a more global view of the situation and to keep the branching factor small when it counts the most. The greatest width of the search tree for the Eternity II puzzle is reached after placing around 160 to 170 pieces. It turns out that good search orders are those which minimize the number of open edges on the board when the search depths with the greatest widths are reached, which is for example the case using a simple rowscan order. Furthermore, the exact order in which the last pieces are placed almost doesn't matter, because the corresponding search depths are reached so rarely that their influence is negligible. The last statement is however not true if specific heuristics are used, for example if some invalid joins are allowed after a certain amount of pieces are placed onto the board.","category":"page"},{"location":"solvers/#Heuristics","page":"Solvers","title":"Heuristics","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Heuristics can be very useful if there are many solutions, but they are less effective if there are only a few solutions. A good heuristic that is used for the Eternity II puzzle is to prioritize the piece candidates with certain edge colors during the first phase of the search, such that some of the colors get eliminated early, which creates an uneven color distribution and increases the probability during the end of the search that the remaining pieces match together.","category":"page"},{"location":"solvers/#Backtracking-search-with-2x2-pieces","page":"Solvers","title":"Backtracking search with 2x2 pieces","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"A different version of the backtracking algorithm uses precomputed compound pieces made of four regular pieces that can be combined into a valid 2times 2 block (figure 2). In each step of the backtracking algorithm a 2times 2 block is placed onto the board. Instead of the original 16times 16 board size, the grid for the compound pieces has only 8 rows and columns, i.e. the depth of the search tree is reduced by a factor of 4. On the other hand, there are a lot more possible 2times 2 compound pieces than the 256 regular pieces, so this approach trades the reduced maximum search depth against a significantly higher branching factor at each level in the search tree.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"<figure style=\"display: flex; justify-content: space-around; flex-wrap: wrap\">\n  <span></span>\n  <figure style=\"width: 20%\">\n    <img src=\"../assets/compound_corner_piece.png\">\n    <figcaption>2x2 corner piece</figcaption>\n  </figure>\n  <figure style=\"width: 20%\">\n    <img src=\"../assets/compound_edge_piece.png\">\n    <figcaption>2x2 edge piece</figcaption>\n  </figure>\n  <figure style=\"width: 20%\">\n    <img src=\"../assets/compound_inner_piece.png\">\n    <figcaption>2x2 inner piece</figcaption>\n  </figure>\n  <figcaption><b>Figure 2</b>: Different types of 2x2 compound pieces</figcaption>\n</figure>","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Instead of the original 5 + 17 = 22 different edge types (frame and inner colors, not counting the border color), there are now 17cdot 17 + 5cdot 17 + 17cdot 5 = 459 possible combinations for the edge types of the compound pieces.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"An advantage could be that the distribution of these 459 macro edge types is not equaly flat as the distribution for the original 22 colors. This could be utilized by heuristics, for example prefer those piece candidates which have the highest number of matching candidate pieces for the open edges.","category":"page"},{"location":"solvers/#Balanced-rotation-sets","page":"Solvers","title":"Balanced rotation sets","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Note that in a valid puzzle solution, for each of the 22 colors the numbers of right edges is equal to the number of left edges on the board with that color, and similarly the numbers of top and bottom edges with that color. Let's call a set of rotations for all pieces balanced, if the edges on the pieces satisfy this condition.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Idea: find a set of \"balanced rotations\" for each of the pieces, such that the numbers of vertical edges (top/bottom) and horizontal edges (left/right) for each color are equal. Hereby only those sets need to be considered which also have each of the four rotations for the four corner pieces exactly once, and exactly 14 edge pieces with each of the four rotations, so that a valid border around the outside of the puzzle board is possible. Then in a second phase, use a regular backtracking algorithm to place the pieces on the board. The fixed rotations reduces the number of possible pre-rotated piece candidates in the lookup table and accordingly the branching factor at each depth in the search tree by factor of 4, which makes an exhaustive search for a balanced rotations set possible.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This could further be combined with \"checkerboard parity\", i.e. divide the pieces into two groups \"black\" and \"white\", such that for each color the number of left edges on the black squares is the same as the number of right edges on the white squares, and so on.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The problem is that there are probably so many possible balanced rotations sets, that this approach might have no advantages over a regular backtracking search. Considering that the orientation of the frame pieces are restricted by their border edges, there are 4cdot C(56 14)cdot C(42 14)cdot C(28 14) possible rotations for the frame pieces and 4^195 possible rotations for the inner pieces, excluding the fixed starter-piece, which in total gives a combined number of 745cdot 10^149 possible rotations for all of the pieces.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To get a rough estimate for the probability of balanced edges for a particular color, we could model the orientation of the edges with that color as a symmetric random walk on a 2-dimensional grid (mathbbZ^2). With this model, for 2n edges of a particular color, the probability that the edges are balanced in both vertical and horizontal direction is given by","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"p_2n = left(left(frac14right)^ncdot C(2n n)right)^2","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"For the 12 inner colors with n=25 joins (50 edges):","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"p_50 approx 00126057","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"For the 5 inner colors with n=24 joins (48 edges):","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"p_48 approx 00131255","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"And for the 5 frame colors with n=12 joins (24 edges):","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"p_24 approx 00259791","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"This model gives an estimated number of 745cdot 10^149cdot p_24^5cdot p_48^5cdot p_50^12approx 553cdot 10^109 different balanced rotations sets.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"reference/#Eternity2Puzzles.Eternity2Puzzle","page":"API Reference","title":"Eternity2Puzzles.Eternity2Puzzle","text":"Eternity2Puzzle()\nEternity2Puzzle(; starter_piece::Bool=true, hint_pieces::Bool=false)\nEternity2Puzzle(pieces::Union{Symbol, String}[, nrows::Int, ncols::Int])\nEternity2Puzzle(nrows::Int, ncols::Int; frame_colors::Int, inner_colors::Int, seed::Int=1, symmetries::Bool=false)\n\nThe Eternity2Puzzle type represents a puzzle instance consisting of the piece definitions and the piece configuration on the board.\n\nThe constructor can be called in different ways:\n\nThe default constructor without arguments creates a puzzle with 16 rows and 16 columns and with the original Eternity II pieces. Keyword arguments starter_piece and hint_pieces control whether the mandatory starter-piece and the four hint pieces from the clue puzzles 1-4 are pre-placed on the board.\n\nA different set of pieces with the corresponding board size can be used by passing either one of the predefined symbols :eternity2, :meta_16x16, :meta_14x14, :meta_12x12, :meta_10x10, :clue1, :clue2, :clue4, or a path to a file containing the edge color numbers for the pieces in the format as described in the README of this package. In the latter case, the input file is expected to contain an additional header line with the numbers of rows and columns of the board. If the header line is missing, the numbers of rows and columns must be declared explicitly by passing two integers in addition to the filepath. If provided, those numbers override the derived size of the board. This can also be used, for example, to solve a smaller sized board using only a subset of the specified pieces.\n\nIf only two integer arguments for the numbers of rows and columns are passed without the pieces argument, a puzzle is created with randomly generated pieces. Optional keyword arguments frame_colors and inner_colors can be used to adjust the numbers of frame and inner color types, and symmetries controls whether the generated pieces must all be unique and not rotationally symmetric.\n\nTo load the piece configuration on the board from a file in .et2 format, use the load! function.\n\nThe Eternity2Puzzle type has two fields; board and pieces. board contains the piece numbers and rotations for each row/column position as a Matrix{UInt16}, where the first 14 bits of each entry represent the piece number and the last 2 bits are used for the rotation in clockwise direction. By convention a value of 0 is used if no piece is placed on a particular position of the board. pieces is a Matrix{UInt8} with rows containing the four color numbers for each of the pieces.\n\nThe Eternity2Puzzle type supports a few basic operations, such as getting or setting a piece on the board by indexing with the row and column numbers directly. The corresponding value is returned or must be provided as a tuple of two integers, representing the piece number and the rotation in clockwise direction. An example how to obtain the number and rotation of the pre-placed starter-piece on square I8 (row 9, column 8) of the original Eternity II puzzle is given below.\n\nExamples\n\njulia> puzzle = Eternity2Puzzle()  # The original Eternity II puzzle\n16×16 Eternity2Puzzle with 1 piece:\n...\n\njulia> puzzle[9, 8]  # Get number and rotation of the piece on square I8 (row 9, column 8)\n(139, 2)\n\njulia> load!(puzzle, \"path/to/saved_board.et2\")  # Load pieces on the board from a file\n\njulia> puzzle = Eternity2Puzzle(:clue1)  # Clue puzzle 1\n6×6 Eternity2Puzzle with 0 pieces:\n...\n\njulia> puzzle = Eternity2Puzzle(8, 8)  # A puzzle with randomly generated pieces\n8×8 Eternity2Puzzle with 64 pieces, 112 matching edge pairs and 0 errors:\n...\n\njulia> reset!(puzzle)  # Clear the entire board\n\njulia> puzzle = Eternity2Puzzle(:eternity2, 12, 12)  # Eternity II pieces, but smaller board\n12×12 Eternity2Puzzle with 0 pieces:\n...\n\n\n\n\n\n","category":"type"},{"location":"reference/#Eternity2Puzzles.Eternity2Solver","page":"API Reference","title":"Eternity2Puzzles.Eternity2Solver","text":"Abstract type for a solver algorithm. \n\n\n\n\n\n","category":"type"},{"location":"reference/#Eternity2Puzzles.SimpleBacktrackingSearch","page":"API Reference","title":"Eternity2Puzzles.SimpleBacktrackingSearch","text":"SimpleBacktrackingSearch()\nSimpleBacktrackingSearch(; seed::Int=1, slip_array::Vector{Int}=[], exhaustive_search::Bool=false)\n\nA simple backtracking search that can be used with arbitrary board sizes. Pre-placed pieces on the board are considered to be additional constraints for a valid solution. This search algorithm places pieces one after another onto the board and backtracks if no more matching piece can be placed. The implementation favours flexibility over maximum performance.\n\nExamples\n\njulia> puzzle = Eternity2Puzzle(:clue1)\n6×6 Eternity2Puzzle with 0 pieces:\n...\n\njulia> solve!(puzzle; alg=SimpleBacktrackingSearch())\n6×6 Eternity2Puzzle with 36 pieces, 60 matching edge pairs and 0 errors:\n  36/1   7/1  23/1  31/1  12/1  26/2\n  25/0  35/3   4/3  29/2  27/1  22/2\n  16/0   8/1   2/1   6/2   1/1  18/2\n  10/0  30/3  32/1  24/2   3/0  13/2\n  20/0  33/2   9/1  19/1   5/2  17/2\n  34/0  21/3  11/3  15/3  28/3  14/3\n\n\n\n\n\n","category":"type"},{"location":"reference/#Eternity2Puzzles.E2BacktrackingSearch","page":"API Reference","title":"Eternity2Puzzles.E2BacktrackingSearch","text":"E2BacktrackingSearch(target_score::Int, seed::Int)\n\nA backtracking algorithm for the original Eternity II puzzle that searches for arrangements with a high number of matching edges, controlled by the target_score parameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Eternity2Puzzles.E2BacktrackingSearch2x2","page":"API Reference","title":"Eternity2Puzzles.E2BacktrackingSearch2x2","text":"A backtracking search using pre-computed 2x2 compound pieces for the original Eternity II puzzle.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Eternity2Puzzles.estimate_solutions","page":"API Reference","title":"Eternity2Puzzles.estimate_solutions","text":"estimate_solutions(puzzle::Eternity2Puzzle)\nestimate_solutions(puzzle::Eternity2Puzzle, path::Union{Symbol, Vector{String}} = :rowscan, slip_array::Vector{Int} = []; verbose::Bool = false)\n\nEstimate the number of solutions for a given Eternity2Puzzle and the total number of nodes in the search tree for a backtracking algorithm, based on an extended version of the probability model for edge matching puzzles developed by Brendan Owen.\n\nPre-placed pieces on the board are considered to be additional constraints that must be satisfied in a solution.\n\nThe order in which pieces are placed onto the board can be controlled with the path argument. It can either be one of the predefined symbols :rowscan (fill row by row, starting from the bottom left corner), :colscan (fill column by column, starting from the bottom left corner), :spiral_in (in clockwise direction, starting from the top-left corner), or path can be given as a Vector{String}, containing all board positions explicitly; for example [\"I8\", \"A1\", \"A2\", \"B1\", ...]. Hereby it is required that each board position occurs exactly once, and that the positions of pre-placed pieces are at the start of the list. Note that if no invalid joins are allowed, the placement order doesn't effect the number of solutions, but it can have a significant influence on the total number of nodes in the search tree.\n\nIf a vector slip_array is given, its entries specify the numbers of placed pieces at which another invalid join is allowed. This means that a piece arrangement is considered to be valid even if not all of the inner joins match. For example the vector [220, 230, 240] specifies that at least the first 219 pieces have to be placed with all edges matching, at least 229 pieces have to be placed with no more than one invalid join, at least 239 pieces with no more than two invalid joins, and for the rest of the pieces there must be no more than three invalid joins in total. Note that all of the frame joins between neighboring frame pieces still have to match exactly.\n\nIf the verbose keyword argument is enabled, the cumulative sum of estimated partial solutions is printed to the console for each depth in the search tree of a backtracking search. This cumulative sum represents the number of nodes that the backtracking algorithm has to visit in order to explore the entire search tree. The ratio between the number of full solutions and cumulative sum of partial solutions can be a measure for the difficulty of the puzzle.\n\nReturn the number of solutions and the total number of nodes in the search tree as a tuple of Float128 values.\n\nExamples\n\nEstimated number of valid solutions for the Eternity II puzzle:\n\njulia> puzzle = Eternity2Puzzle()\n16×16 Eternity2Puzzle with 1 piece:\n...\n\njulia> trunc(Int, estimate_solutions(puzzle)[1])\n14702\n\nEstimated average number of nodes that a backtracking algorithm has to visit in order to find a full solution, using a row-by-row search path starting at the bottom left corner:\n\njulia> solutions, nodes = estimate_solutions(puzzle)\n(1.47022707008833935129885673337590720e+04, 1.36503111141314673778599540194846603e+47)\n\njulia> nodes/solutions\n9.28449175766521657015077720929987568e+42\n\nReferences\n\nhttps://groups.io/g/eternity2/message/5209\nhttps://groups.io/g/eternity2/message/6408\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.play","page":"API Reference","title":"Eternity2Puzzles.play","text":"play()\nplay(:clue1)\nplay(:clue2)\nplay(:clue4)\n\nStart the interactive game.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.preview","page":"API Reference","title":"Eternity2Puzzles.preview","text":"preview(puzzle::Eternity2Puzzle)\n\nOpen a preview image of the puzzle board.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.solve!","page":"API Reference","title":"Eternity2Puzzles.solve!","text":"solve!(puzzle::Eternity2Puzzle)\nsolve!(puzzle::Eternity2Puzzle; alg::Eternity2Solver)\n\nStart to search for a solution of the given Eternity2Puzzle.\n\nExamples\n\njulia> puzzle = Eternity2Puzzle()\n\njulia> solve!(puzzle)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.reset!","page":"API Reference","title":"Eternity2Puzzles.reset!","text":"reset!(puzzle::Eternity2Puzzle)\n\nClear all pieces from the board (except for the starter-piece in case of the 16×16 board).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.load!","page":"API Reference","title":"Eternity2Puzzles.load!","text":"load!(puzzle::Eternity2Puzzle, filename::AbstractString)\n\nLoad the pieces on the board from a file in .et2 format.\n\nThe board dimensions of the given Eternity2Puzzle must be compatible with the numbers of rows and columns in the input file.\n\nSee also save.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.save","page":"API Reference","title":"Eternity2Puzzles.save","text":"save(puzzle::Eternity2Puzzle, filename::AbstractString)\n\nSave the board of a given Eternity2Puzzle to a file in .et2 format.\n\nSee also load!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Internal-functions","page":"API Reference","title":"Internal functions","text":"","category":"section"},{"location":"reference/#Eternity2Puzzles.score","page":"API Reference","title":"Eternity2Puzzles.score","text":"score(puzzle::Eternity2Puzzle)\n\nReturn the numbers of matching and non-matching edge pairs on the board.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.remap_piece_colors","page":"API Reference","title":"Eternity2Puzzles.remap_piece_colors","text":"remap_piece_colors(puzzle::Eternity2Puzzle)\n\nRemap and reorder the color numbers such that colors are consecutive numbers starting at 1, with all frame color numbers first and all inner color numbers last. The border color and another \"virtual\" border color for the corner pieces are appended to the end of the number list.\n\nWhile the relative orderings of the color numbers within the set of the frame colors and the set of the inner colors are preserved, gaps between the color numbers are eliminated, so that they can be used as array indices.\n\nReturn a new matrix for the piece definitions using the remapped color numbers, and two UnitRanges for the numbers of the remapped frame colors and inner colors.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.symmetry_factor","page":"API Reference","title":"Eternity2Puzzles.symmetry_factor","text":"symmetry_factor(puzzle::Eternity2Puzzle)\n\nReturn the number of symmetries in the puzzle as a one-based factor, i.e. if there aren't any symmetries, the return value is 1. Symmetries can happen due to rotationally symmetric individual pieces, (rotationally identical) duplicate pieces, and possible rotations of the board if there aren't any fixed pieces on the board. The total number of puzzle solutions is divisible by this factor. When using a backtracking algorithm to enumerate all solutions of a given puzzle, it can be advantageous to first eliminate all the symmetries, for example by fixing one of the corner pieces and by restricting the rotations of the rotationally symmetric pieces, and then to multiply the number of found solutions by the corresponding factor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Eternity2Puzzles.generate_pieces","page":"API Reference","title":"Eternity2Puzzles.generate_pieces","text":"generate_pieces(nrows::Int, ncols::Int, frame_colors::Int, inner_colors::Int, seed::Int, symmetries::Bool)\n\nGenerate random pieces for an Eternity II style puzzle with nrows rows, ncols columns, frame_colors frame colors and inner_colors inner colors.\n\nnrows and ncols must be between 3 and 20.\n\nsymmetries controls whether the generated pieces must all be unique and not rotationally symmetric. If set to false and no such pieces can be generated for the given numbers of frame colors and inner colors after maxiters iterations, the function throws an error.\n\nReturn a valid arrangement on the board (i.e. puzzle solution) and a matrix with the edge colors for the pieces.\n\n\n\n\n\n","category":"function"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"compat: Compat\nThe latest version of Eternity2Puzzles.jl requires Julia v1.10 or newer.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Eternity2Puzzles.jl is registered in the Julia package registry and can be installed with Julia's built-in package manager. In the Julia REPL press ] to enter the package mode and run the command","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> ]\n\npkg> add Eternity2Puzzles","category":"page"},{"location":"#Basic-usage","page":"Overview","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"In the Julia REPL, first load the package","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Eternity2Puzzles","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To start the interactive game in a new window, simply type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> play()","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Puzzle pieces can be moved with the left mouse button and rotated with a right click. The goal is to place all 256 pieces on the board, such that the colors and symbols of adjoining pairs of edges match, and with the grey edges around the outside. Piece number 139 is a mandatory starter-piece with a fixed position on the board, that can neither be moved nor rotated.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can also use the following commands to play one of the smaller clue puzzles:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> play(:clue1)\n\njulia> play(:clue2)\n\njulia> play(:clue3)\n\njulia> play(:clue4)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"warning: Warning\nPlease note that the package is only tested on Windows and that the interactive game part might not work correctly on a Mac with Retina display.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The basic type provided by this package is Eternity2Puzzle. This type represents a puzzle with the piece arrangement on the board and the edge color definitions for the pieces. A puzzle instance with the original Eternity II pieces and with an empty board can be created using the default constructor:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Eternity2Puzzles  # hide\npuzzle = Eternity2Puzzle()","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The output shows a representation of the board, with the piece numbers and with the piece rotations as number of quarter rotations in clockwise direction. For the default puzzle there is only the starter-piece pre-placed on square I8, and the other squares that don't have numbers on them are empty.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A custom definition for the edge colors of the puzzle pieces can be loaded from a file by passing the filepath as an argument to the Eternity2Puzzle constructor:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> puzzle = Eternity2Puzzle(\"path/to/e2pieces.txt\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Such an input file must be in plain text format and contain lines with four color numbers on each line, separated by spaces. The numbers of rows and columns of the board can optionally be specified on the first line; for example","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"16 16\n0 0 1 3\n0 0 1 4\n...","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The color numbers for each piece are ordered in clockwise direction, starting with the bottom side (i.e. bottom, left, top, right). The numbering convention for the different color patterns is shown in the Color patterns section below.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The constructor accepts more arguments to specify the board size if it is not given in the input file, or in order to force a different board size, and also to create puzzles with other predefined or randomly generated sets of pieces. For more details please see the description in the API Reference.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Call the solve! function to start the default backtracking search algorithm. You can press and hold Ctrl + C in the REPL to stop the search.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> solve!(puzzle)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To open a visualization of the puzzle board use","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> preview(puzzle)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"tip: Tip\nIf your terminal emulator supports the Sixel graphics format, the puzzle board can also be rendered directly inside the REPL by loading the ImageInTerminal.jl package. It is possible to toggle between the regular text output and image display using the ImageInTerminal.disable_encoding() and ImageInTerminal.enable_encoding() functions.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The solve! function accepts an optional keyword argument alg, which should a subtype of Eternity2Solver and selects the algorithm that is used to search for a solution of the given Eternity2Puzzle.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To write a custom solver algorithm, define a new subtype of Eternity2Solver and implement a two-argument solve! method with your solver type as the type of the second positional argument:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"struct MySolver <: Eternity2Solver end\n\nfunction solve!(puzzle::Eternity2Puzzle, solver::MySolver)\n    # ...\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Then you can use an instance of the solver with the alg keyword argument:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> solve!(puzzle; alg=MySolver())","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The solve! method with a single positional argument is just a thin wrapper that dispatches on the different solver types, handles keyboard interrupts and displays the elapsed time.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In case a solution is found, the custom solve! implementation is expected to update the puzzle.board array which contains the arrangement and the rotations for all puzzle pieces on the board, see Eternity2Puzzle for details.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The number of solutions for any given Eternity2Puzzle can be estimated without solving the puzzle using the estimate_solutions function:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Eternity2Puzzles  # hide\npuzzle = Eternity2Puzzle();\nsolutions, nodes = estimate_solutions(puzzle)\ntrunc(Int, solutions)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The return values of this function are the estimated number of solutions and the estimated number of nodes in the search tree for a backtracking search algorithm, as 128-bit floating point numbers. These values depend on the board size, the pre-placed pieces on the board, the numbers of different frame and inner color types, the frequencies/distribution of the colors over the pieces, and more. estimate_solutions accepts additional arguments that control permitted invalid joins and the placement order for a backtracking search.","category":"page"},{"location":"#Color-patterns","page":"Overview","title":"Color patterns","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The following numbering convention for the different color patterns is used by this package:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Color patterns)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the solver algorithms and for other functions provided by this package it is not strictly necessary that the edge colors that are specified in an input file follow this numbering, except for the border color which must always be 0.","category":"page"}]
}
